<?php
/**
 * Yii2 cURL wrapper
 * With RESTful support.
 *
 * @category  Web-yii2
 * @package   yii2-curl
 * @author    Nils Gajsek <info@linslin.org>
 * @copyright 2013-2015 Nils Gajsek<info@linslin.org>
 * @license   http://opensource.org/licenses/MIT MIT Public
 * @version   1.0.7
 * @link      http://www.linslin.org
 *
 */

 /**
  * Modifications to function move and function rename
  * Directions: Copy to crab/vendor/marnold22/yii2-curl.
  * Delete the "Curl.php" file there and then rename this file
  * as "Curl.php" to replace it.
  * Edited on 7/9/19 by Alyssa Fusato 
  */

namespace marnold22\yii2\curl;

use Yii;
use yii\base\Exception;
use yii\helpers\Json;
use yii\web\HttpException;
use yii\base\UserException;

/**
 * cURL class
 */
class Curl
{

    // ################################################ class vars // ################################################


    /**
     * @var string
     * Holds response data right after sending a request.
     */
    public $response = null;

    /**
     * @var integer HTTP-Status Code
     * This value will hold HTTP-Status Code. False if request was not successful.
     */
    public $responseCode = null;

    /**
     * @var array HTTP-Status Code
     * Custom options holder
     */
    private $_options = array();


    /**
     * @var object
     * Holds cURL-Handler
     */
    private $_curl = null;


    /**
     * @var array default curl options
     * Default curl options
     */
    private $_defaultOptions = array(
        CURLOPT_USERAGENT      => 'Yii2-Curl-Agent',
        CURLOPT_TIMEOUT        => 30,
        CURLOPT_CONNECTTIMEOUT => 30,
        CURLOPT_RETURNTRANSFER => true,
        CURLOPT_HEADER         => false,
    );



    // ############################################### class methods // ##############################################

    /**
     * Start performing GET-HTTP-Request
     *
     * @param string  $url
     * @param boolean $raw if response body contains JSON and should be decoded
     *
     * @return mixed response
     */
    public function get($url, $raw = true)
    {
        return $this->_httpRequest('GET', $url, $raw);
    }


    /**
     * Start performing HEAD-HTTP-Request
     *
     * @param string $url
     *
     * @return mixed response
     */
    public function head($url)
    {
        return $this->_httpRequest('HEAD', $url);
    }


    /**
     * Start performing POST-HTTP-Request
     *
     * @param string  $url
     * @param boolean $raw if response body contains JSON and should be decoded
     *
     * @return mixed response
     */
    public function post($url, $raw = true)
    {
        return $this->_httpRequest('POST', $url, $raw);
    }


    /**
     * Start performing PUT-HTTP-Request
     *
     * @param string  $url
     * @param boolean $raw if response body contains JSON and should be decoded
     *
     * @return mixed response
     */
    public function put($url, $raw = true)
    {
        return $this->_httpRequest('PUT', $url, $raw);
    }

      /**
     * Start performing MKCOL-HTTP-Request
     *
     * @param string  $url
     * @param boolean $raw if response body contains JSON and should be decoded
     *
     * @return mixed response
     */
    public function mkcol($url, $raw = true)
    {
        $response = $this->_httpRequest('MKCOL', $url, $raw);

        $p = xml_parser_create();
        xml_parse_into_struct($p, $response, $vals, $index);
        xml_parser_free($p);
        // error_log("VALS: " . json_encode($vals));
        // error_log("INDEX: " . json_encode($index));
        // error_log("RESPONSE: " . json_encode($response));

        if ( $response == "" ) {
          return true;
        } else {
          throw new UserException($vals[$index['S:MESSAGE'][0]]['value']);
          return false;
        }
    }


    /**
     * Start performing PROPFIND-HTTP-Request
     *
     * @param string  $url
     * @param boolean $raw if response body contains JSON and should be decoded
     *
     * @return mixed response
     */
    public function propfind($url, $raw = true)
    {
        return $this->_httpRequest('PROPFIND', $url, $raw);
    }


    public function has($url)
    {

      $response = $this->propfind($url);
      $p = xml_parser_create();
      xml_parse_into_struct($p, $response, $vals, $index);
      xml_parser_free($p);
      // error_log("VALS: " . json_encode($vals));
      // error_log("INDEX: " . json_encode($index));
      // error_log("RESPONSE: " . json_encode($response));

      if ( array_key_exists('D:STATUS', $index) && strpos($vals[$index['D:STATUS'][0]]['value'], 'OK') !==false) {
        return true;
      } else {
        return false;
      }
    }

    public function rename($absSourceUrl, $relativeDest, $host)
    {
      $response = $this->move($absSourceUrl, $relativeDest, $host, true);
      Yii::error("\r\n" . 'Response is ' . $response[0]);

      if ( $response[0] == "HTTP/1.1 201 Created" ) {
        Yii::error("\r\n" . 'Returning True');
        return true;
      } else {
        Yii::error("\r\n" . 'Returning False');
        return false;
      }
    }

    /**
     * Start performing MOVE-HTTP-Request
     *
     * @param string  $url
     * @param boolean $raw if response body contains JSON and should be decoded
     *
     * @return mixed response
     */
    public function move($absSourceUrl, $relativeDest, $host, $raw = true) /* absSourceURL is old name, relativeDest is new name */
    {
        $this->setOption(CURLOPT_HEADER, true);
        $this->setOption(CURLOPT_HTTPHEADER, ['Destination:' . $relativeDest]);
        /* $url = $absSourceUrl . ' HTTPS/1.1\r\nHost: ' . $host;*/ //<- Mistake
        $this->setOption(CURLOPT_URL, $absSourceUrl);
        
        return $this->_httpRequest('MOVE', '', $raw);
    }


    /**
     * Start performing DELETE-HTTP-Request
     *
     * @param string  $url
     * @param boolean $raw if response body contains JSON and should be decoded
     *
     * @return mixed response
     */
    public function delete($url, $raw = true)
    {
        $response = $this->_httpRequest('DELETE', $url, $raw);

        $p = xml_parser_create();
        xml_parse_into_struct($p, $response, $vals, $index);
        xml_parser_free($p);
        // error_log("VALS: " . json_encode($vals));
        // error_log("INDEX: " . json_encode($index));
        // error_log("RESPONSE: " . json_encode($response));

        if ( $response == "" ) {
          return true;
        } else {
          throw new UserException($vals[$index['S:MESSAGE'][0]]['value']);
          return false;
        }
    }


    /**
     * Set curl option
     *
     * @param string $key
     * @param mixed  $value
     *
     * @return $this
     */
    public function setOption($key, $value)
    {
        //set value
        if (array_key_exists($key, $this->_defaultOptions) && $key !== CURLOPT_WRITEFUNCTION) {
            $this->_defaultOptions[$key] = $value;
        } else {
            $this->_options[$key] = $value;
        }

        //return self
        return $this;
    }


    /**
     * Set curl options
     *
     * @param array $options
     *
     * @return $this
     */
    public function setOptions($options)
    {
        $this->_options = $options + $this->_options;

        return $this;
    }


    /**
     * Unset a single curl option
     *
     * @param string $key
     *
     * @return $this
     */
    public function unsetOption($key)
    {
        //reset a single option if its set already
        if (isset($this->_options[$key])) {
            unset($this->_options[$key]);
        }

        return $this;
    }


    /**
     * Unset all curl option, excluding default options.
     *
     * @return $this
     */
    public function unsetOptions()
    {
        //reset all options
        if (isset($this->_options)) {
            $this->_options = array();
        }

        return $this;
    }


    /**
     * Total reset of options, responses, etc.
     *
     * @return $this
     */
    public function reset()
    {
        if ($this->_curl !== null) {
            curl_close($this->_curl); //stop curl
        }

        //reset all options
        if (isset($this->_options)) {
            $this->_options = array();
        }

        //reset response & status code
        $this->_curl = null;
        $this->response = null;
        $this->responseCode = null;

        return $this;
    }


    /**
     * Return a single option
     *
     * @param string|integer $key
     * @return mixed|boolean
     */
    public function getOption($key)
    {
        //get merged options depends on default and user options
        $mergesOptions = $this->getOptions();

        //return value or false if key is not set.
        return isset($mergesOptions[$key]) ? $mergesOptions[$key] : false;
    }


    /**
     * Return merged curl options and keep keys!
     *
     * @return array
     */
    public function getOptions()
    {
        return $this->_options + $this->_defaultOptions;
    }


    /**
     * Get curl info according to http://php.net/manual/de/function.curl-getinfo.php
     *
     * @return mixed
     */
    public function getInfo($opt = null)
    {
        if ($this->_curl !== null && $opt === null) {
            return curl_getinfo($this->_curl);
        } elseif ($this->_curl !== null && $opt !== null) {
            return curl_getinfo($this->_curl, $opt);
        } else {
            return [];
        }
    }


    /**
     * Performs HTTP request
     *
     * @param string  $method
     * @param string  $url
     * @param boolean $raw if response body contains JSON and should be decoded -> helper.
     *
     * @throws Exception if request failed
     *
     * @return mixed
     */
    private function _httpRequest($method, $url, $raw = false)
    {
        //set request type and writer function
        $this->setOption(CURLOPT_CUSTOMREQUEST, strtoupper($method));

        //check if method is head and set no body
        if ($method === 'HEAD') {
            $this->setOption(CURLOPT_NOBODY, true);
            $this->unsetOption(CURLOPT_WRITEFUNCTION);
        }

        //setup error reporting and profiling
        Yii::trace('Start sending cURL-Request: '.$url.'\n', __METHOD__);
        Yii::beginProfile($method.' '.$url.'#'.md5(serialize($this->getOption(CURLOPT_POSTFIELDS))), __METHOD__);

        /**
         * proceed curl
         */
        $this->_curl = curl_init($url);
        curl_setopt_array($this->_curl, $this->getOptions());
        $body = curl_exec($this->_curl); 
        Yii::error('In _curl is ' . json_encode(curl_getinfo($this->_curl)));

        //check if curl was successful
        if ($body === false) {
            switch (curl_errno($this->_curl)) {
                case 7:
                    $this->responseCode = 'timeout';
                    return false;
                    break;

                default:
                    throw new Exception('curl request failed: ' . curl_error($this->_curl), curl_errno($this->_curl));
                    break;
            }
        }

        //retrieve response code
        $this->responseCode = curl_getinfo($this->_curl, CURLINFO_HTTP_CODE);
        $this->response = $body;

        //end yii debug profile
        Yii::endProfile($method.' '.$url .'#'.md5(serialize($this->getOption(CURLOPT_POSTFIELDS))), __METHOD__);

        //check responseCode and return data/status
        if ($this->getOption(CURLOPT_CUSTOMREQUEST) === 'MOVE') {
            // error_log("RESP: " . json_encode($this->response));
            $this->response = explode("\r\n", $this->response);
            // error_log('RESP[0]: ' . $this->response[0]);
            // $raw ? $this->response :
            return $this->response;
        }
        else if ($this->getOption(CURLOPT_CUSTOMREQUEST) === 'HEAD') {
            return true;
        } else {
            // $this->response = $raw ? $this->response : Json::decode($this->response);
            return $this->response;
        }
    }
}
